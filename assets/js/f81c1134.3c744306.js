"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[8130],{77735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"htmx-por-que-eu-uso","metadata":{"permalink":"/blog/htmx-por-que-eu-uso","source":"@site/blog/2024-05-19-htmx-por-que-uso/index.md","title":"HTMX: por que eu uso?","description":"This is my first post on Docusaurus.","date":"2024-05-19T00:00:00.000Z","tags":[{"inline":true,"label":"HTMX","permalink":"/blog/tags/htmx"},{"inline":true,"label":"Django","permalink":"/blog/tags/django"}],"readingTime":4.91,"hasTruncateMarker":true,"authors":[{"name":"Eduardo Oliveira","title":"Co-creator of Docusaurus 1","url":"https://github.com/EduardoJM","email":"eduardo_y05@outlook.com","page":null,"socials":{"github":"https://github.com/EduardoJM","bluesky":"https://bsky.app/profile/goticodocalypso.dev"},"imageURL":"https://github.com/EduardoJM.png","key":"EduardoJM"}],"frontMatter":{"title":"HTMX: por que eu uso?","description":"This is my first post on Docusaurus.","slug":"htmx-por-que-eu-uso","authors":["EduardoJM"],"tags":["HTMX","Django"]},"unlisted":false,"nextItem":{"title":"Django, Htmx e React: usando HTMX para al\xe9m de TODO-Lists","permalink":"/blog/django-htmx-react-alem-de-todo-lists"}},"content":"Nos \xfaltimos dias surgiram diversos tweets com opini\xf5es, indica\xe7\xf5es, ou pedindo textos de refer\xeancia sobre o uso do HTMX. Optei pelo uso do HTMX em alguns projetos, inclusive em produ\xe7\xe3o, e pela falta de conte\xfados mostrando usos reais da biblioteca, decidi come\xe7ar a escrever. Esse texto, em espec\xedfico, nasceu de alguns desses questionamentos do twitter.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Conte\xfados <a name=\\"content\\" />\\n\\n- [Conte\xfados](#content)\\n- [Introdu\xe7\xe3o](#intro)\\n- [O que \xe9 o HTMX?](#o-que-e)\\n- [Contexto e Motivos pela escolha](#context)\\n  - [1. Template Engine](#template-engine)\\n  - [2. Django-Admin](#django-admin)\\n  - [3. Autentica\xe7\xe3o e Permiss\xe3o](#auth)\\n  - [4. Funcionalidades do Django](#features)\\n  - [5. Escopo](#scope)\\n- [Alguns contrapontos](#points)\\n- [Quer dizer, ent\xe3o, que agora eu s\xf3 uso HTMX?](#end)\\n\\n## Introdu\xe7\xe3o <a name=\\"intro\\" />\\n\\nEsse texto foi inspirado por uma publica\xe7\xe3o do Mario Souto ([omariosouto](https://x.com/omariosouto)) no twitter ao questionar sobre a quantidade de gente indicando HTMX recentemente e se essas pessoas estavam usando HTMX em produ\xe7\xe3o.\\n\\nO tweet pode ser visto abaixo:\\n\\n![Tweet de Mario Souto com o texto: \\"Todo mundo que fala pro povo usar HTMX t\xe1 usando em prod? Ou \xe9 s\xf3 hype coletivo? Eu queria entender as pessoas que categoricamente sugerem algo que nem elas tem experi\xeancia.\\"](./tweet.png)\\n\\nTenho trabalhado com HTMX (Django + HTMX, pra especificar a stack), inclusive em produ\xe7\xe3o (Veja o texto [Django, Htmx e React: usando HTMX para al\xe9m de TODO-Lists](https://dev.to/eduardojm/django-htmx-e-react-usando-htmx-para-alem-de-todo-lists-3amo)) e resolvi escrever esse texto para elucidar o contexto e os motivos que me levaram a decis\xe3o de us\xe1-lo.\\n\\n## O que \xe9 o HTMX? <a name=\\"o-que-e\\" />\\n\\n> htmx gives you access to AJAX, CSS Transitions, WebSockets and Server Sent Events directly in HTML, using attributes, so you can build modern user interfaces with the simplicity and power of hypertext\\n>\\n> Home do [htmx.org](https://htmx.org/)\\n\\nResumidamente, o HTMX \xe9 uma biblioteca JavaScript que permite que voc\xea use transi\xe7\xf5es, fa\xe7a requisi\xe7\xf5es e coisas do tipo utilizando atributos HTML para construir interfaces modernas utilizando HTML (principalmente em servidores que renderizam HTML, como \xe9 o caso do Django).\\n\\n![meme sobre usar html](./htmx.jpg)\\n\\n## Contexto e Motivos pela escolha <a name=\\"context\\" />\\n\\n### 1. Template Engine <a name=\\"template-engine\\" />\\n\\nO Django \xe9, por padr\xe3o, um framework que implementa um sistema de templates que devolve HTML para o navegador. Junto com o sistema de templates, existe um sistema de gerenciamento de arquivos est\xe1ticos.\\n\\nEsse primeiro contexto \xe9 importante aqui pois ao utilizar a stack Django + HTMX, n\xe3o \xe9 necess\xe1rio implementar, adaptar ou configurar nenhum sistema de templates.\\n\\n### 2. Django-Admin <a name=\\"django-admin\\" />\\n\\nO [Django-Admin](https://docs.djangoproject.com/en/5.0/ref/contrib/admin/) \xe9 uma aplica\xe7\xe3o (ou um m\xf3dulo, por assim chamar), inclu\xedda junto a distribui\xe7\xe3o django e que fornece uma interface de administra\xe7\xe3o f\xe1cil de ser utilizada para gerenciar os **models** criados dentro dos projetos.\\n\\nA partir do item anterior, j\xe1 \xe9 poss\xedvel imaginar que o Django-Admin usa, fundamentalmente, templates HTML e renderiza\xe7\xe3o server-side (que devolve o HTML).\\n\\nEm alguns casos, quando h\xe1 a necessidade de alguma funcionalidade com maior dinamiza\xe7\xe3o dentro do django-admin \xe9 mais fact\xedvel e r\xe1pido usar uma biblioteca que fa\xe7a a ponte para o mesmo sistema de templates HTML que utilizar um framework ou biblioteca front-end, como o React.\\n\\n### 3. Autentica\xe7\xe3o e Permiss\xe3o <a name=\\"auth\\" />\\n\\nAssim como o conjunto de utilit\xe1rios para o painel administrativo, o django traz por padr\xe3o um sistema de autentica\xe7\xe3o e permiss\xf5es configur\xe1vel e utilizar o HTMX remove a necessidade de inserir outros tipos de autentica\xe7\xe3o (como JWT amplamente usada para API\'s).\\n\\n> Outro ponto relevante sobre a autentica\xe7\xe3o e permiss\xe3o \xe9 que ao utilizar o Django-Admin e uma aplica\xe7\xe3o Django padr\xe3o server-side, a autentica\xe7\xe3o entre ambiente de admin e aplica\xe7\xe3o \xe9 compartilhada de forma simples, j\xe1 que, na pr\xe1tica, \xe9 o mesmo site.\\n\\n### 4. Funcionalidades do Django <a name=\\"features\\" />\\n\\nO Django possui facilitadores como sistema de formul\xe1rios e widgets que se integram muito bem com a Template Engine e facilitam coisas como validar os dados e, consequentemente, armazenar no banco de dados.\\n\\n### 5. Escopo <a name=\\"scope\\" />\\n\\nTudo o que descrevi acima foi bastante decisivo para a escolha do HTMX, mas, talvez, o que tenha sido mais decisivo foram os escopos das aplica\xe7\xf5es e funcionalidades onde o HTMX foi utilizado. S\xe3o escopos onde os formul\xe1rios s\xe3o simples, n\xe3o exigiam muitas manipula\xe7\xf5es ou valida\xe7\xf5es. N\xe3o existem formul\xe1rios com muita complexidade (por exemplo, um formul\xe1rio de cadastro de cliente onde voc\xea pode adicionar v\xe1rios dependentes no cadastro, etc.).\\n\\n> Mesmo que na maioria dos formul\xe1rios complexos eu considere como falha de decis\xf5es, nem sempre essas decis\xf5es s\xe3o dos devs.\\n\\nDados os motivos acima, ter conhecimento do framework de back-end / server-side ao qual se vai trabalhar, aliado ao HTMX, \xe9 importante para decidir se os requisitos dos formul\xe1rios e outras necessidades podem, ou n\xe3o, se tornar empecilhos.\\n\\n## Alguns contrapontos <a name=\\"points\\" />\\n\\nNem tudo s\xe3o flores.\\n\\nEm algumas situa\xe7\xf5es \xe9 dif\xedcil fazer o que se quer fazer com a biblioteca, principalmente pela baixa quantidade, atualmente, de conte\xfados.\\n\\nAssim como em framework\'s front-end, como o react, lidar com redirecionamento de URL\'s pode ser bastante complexo, por exemplo pra preservar filtros em requisi\xe7\xf5es via HTMX.\\n\\n> Existem algumas complexidades com que eu preciso lidar que eu, no atual momento, n\xe3o transfiro essa responsabilidade ao HTMX e, portanto, n\xe3o irei list\xe1-las aqui.\\n\\n## Quer dizer, ent\xe3o, que agora eu s\xf3 uso HTMX? <a name=\\"end\\" />\\n\\nBem, n\xe3o. Por mais que eu tenha gostado bastante do desenvolvimento com o HTMX integrado ao Django, uso em poucos projetos e, na maioria das vezes, n\xe3o \xe9 a \xfanica forma de dinamiza\xe7\xe3o das p\xe1ginas (em alguns casos \xe9 preciso utilizar bastante JavaScript Vanilla ou outras bibliotecas como o React).\\n\\nAl\xe9m disso, algumas aplica\xe7\xf5es com as quais trabalho continuam sendo feitas com API\'s Rest usando JSON e front-end\'s como SPA\'s.\\n\\nTudo depende da an\xe1lise dos pontos listados acima e de contextos das necessidades do neg\xf3cio, se o projeto j\xe1 est\xe1 em andamento, se existe time, se \xe9 um projeto que farei sozinho como freelancer, dentre outras quest\xf5es."},{"id":"django-htmx-react-alem-de-todo-lists","metadata":{"permalink":"/blog/django-htmx-react-alem-de-todo-lists","source":"@site/blog/2024-04-09-django-htmx-react-todo/index.md","title":"Django, Htmx e React: usando HTMX para al\xe9m de TODO-Lists","description":"This is my first post on Docusaurus.","date":"2024-04-09T00:00:00.000Z","tags":[{"inline":true,"label":"Django","permalink":"/blog/tags/django"},{"inline":true,"label":"HTMX","permalink":"/blog/tags/htmx"},{"inline":true,"label":"React","permalink":"/blog/tags/react"}],"readingTime":5.605,"hasTruncateMarker":true,"authors":[{"name":"Eduardo Oliveira","title":"Co-creator of Docusaurus 1","url":"https://github.com/EduardoJM","email":"eduardo_y05@outlook.com","page":null,"socials":{"github":"https://github.com/EduardoJM","bluesky":"https://bsky.app/profile/goticodocalypso.dev"},"imageURL":"https://github.com/EduardoJM.png","key":"EduardoJM"}],"frontMatter":{"title":"Django, Htmx e React: usando HTMX para al\xe9m de TODO-Lists","description":"This is my first post on Docusaurus.","slug":"django-htmx-react-alem-de-todo-lists","authors":["EduardoJM"],"tags":["Django","HTMX","React"]},"unlisted":false,"prevItem":{"title":"HTMX: por que eu uso?","permalink":"/blog/htmx-por-que-eu-uso"},"nextItem":{"title":"Full-Text Search: Criando um Back-End de Filtro para o Django Rest-Framework","permalink":"/blog/full-text-search-drf-postgres-django"}},"content":"J\xe1 faz algum tempo que o **HTMX**, que me foi apresentado pelo [@JeffQuesado](https://twitter.com/JeffQuesado), me pareceu uma ideia muito legal para se trabalhar junto com Django, principalmente o **Django-Admin** que j\xe1 tem uma estrutura fortemente baseada em _server-side_.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Conte\xfados <a name=\\"contents\\"></a>\\n\\n- [Conte\xfados](#contents)\\n- [Introdu\xe7\xe3o](#intro)\\n- [Contextualiza\xe7\xe3o da Plataforma Atual](#context)\\n- [Entendendo o Problema](#problem)\\n- [Por que HTMX se j\xe1 us\xe1vamos React?](#why)\\n- [Quest\xf5es t\xe9cnicas](#tech)\\n- [Comunica\xe7\xe3o entre HTMX e React](#react)\\n- [Confirma\xe7\xe3o para execu\xe7\xe3o de a\xe7\xf5es](#confirm)\\n- [Como \xe9 que isso ai funciona?](#how)\\n- [E o futuro?](#future)\\n\\n## Introdu\xe7\xe3o <a name=\\"intro\\"></a>\\n\\nEm uma demanda de um dos projetos em que atuo, precis\xe1vamos de uma funcionalidade para a qual o uso do **HTMX** se encaixaria perfeitamente e esse texto tem como objetivo levantar quest\xf5es pelas quais foi decidido o uso do **HTMX** e n\xe3o de outras ferramentas e elucidar como foram feitas integra\xe7\xf5es entre **Django**, **HTMX** e **React** para construir ferramentas reais.\\n\\n> O t\xedtulo \xe9 uma inspira\xe7\xe3o de um _tweet_ que vi, alguns dias atr\xe1s, que questionava se algu\xe9m estava utilizando o **HTMX** para algo mais al\xe9m de criar TODO-Lists.\\n\\n## Contextualiza\xe7\xe3o da Plataforma Atual <a name=\\"context\\"></a>\\n\\nO back-end do projeto utiliza o **Django** com **Django-Rest-Framework** para servir uma API de integra\xe7\xe3o para um app mobile e, para gerenciamento dos conte\xfados, o **Django-Admin** \xe9 utilizado.\\n\\nO django-admin possu\xed, nas p\xe1ginas de formul\xe1rio, uma estrutura parecida com a seguinte: um cabe\xe7alho ocupado toda a largura da p\xe1gina, e logo a baixo uma sidebar e o conte\xfado principal, que no caso \xe9 um formul\xe1rio.\\n\\n![Cabe\xe7alho ocupando toda a largura da p\xe1gina e logo abaixo uma sidebar e o conte\xfado principal, que no caso \xe9 um formul\xe1rio](./applayout.png)\\n\\nEm alguns formul\xe1rios, a estrutura e arquitetura de informa\xe7\xe3o dos _models_ demandava um controle de carregamento e de exibi\xe7\xe3o de itens complexo usando _lazy-loading_. Desse modo, quando o ferramental do **django** e do **django-admin** deixou de suprir as necessidades, parte desses formul\xe1rios foi constru\xedda utilizando aplica\xe7\xf5es pequenas com **React**.\\n\\nEssas aplica\xe7\xf5es **React** que eram carregadas apenas em p\xe1ginas espec\xedficas n\xe3o demandavam, por exemplo, o uso de _routers_ e coisas do tipo.\\n\\n## Entendendo o Problema <a name=\\"problem\\"></a>\\n\\nO painel de administra\xe7\xe3o \xe9 utilizado para algo pr\xf3ximo a um CMS (_content management system_) para um app de idiomas. Durante a cria\xe7\xe3o de algumas \\"entidades\\" dentro da plataforma, seria necess\xe1rio uma ferramenta, em _popup_, para consultar as \\"entidades\\" j\xe1 cadastradas, pois esse processo atualmente era gerenciado com planilhas externas, aumentando a complexidade no uso do painel.\\n\\nEssa mesma ferramenta deveria, tamb\xe9m, fornecer a op\xe7\xe3o de clonar entidades para a p\xe1gina em que se estava trabalhando (alternado a entidade pa\xed/chave estrangeira).\\n\\n## Por que HTMX se j\xe1 us\xe1vamos React? <a name=\\"why\\"></a>\\n\\nQuando come\xe7amos a avaliar a funcionalidade, a primeira discuss\xe3o foi: ser\xe1 que o **HTMX** se encaixa bem aqui? ou ser\xe1 melhor lidar com **React**?\\n\\nUm dos principais pontos levados em considera\xe7\xe3o: a estrutura do **django** e do **django-admin** j\xe1 trazia uma quantidade enorme de c\xf3digo e funcionalidades que poderiam ser reutilizadas para a exibi\xe7\xe3o, como pagina\xe7\xe3o, etc. na aplica\xe7\xe3o **react** que roda nessa aplica\xe7\xe3o n\xe3o lidava com pagina\xe7\xe3o nem com diversas outras coisas que demandaria muito mais tempo para implementar que utilizando partes dos _templates_ do **django-admin** adaptados.\\n\\nComo essa funcionalidade n\xe3o seria, sempre, inserida nas mesmas p\xe1ginas que o formul\xe1rio **react**, haveria muito trabalho pra conciliar o uso do **react**, **bundlers**, etc.\\n\\nEsse conjunto de fatores foram os principais motivantes para a ado\xe7\xe3o do **HTMX**, que diferente do **react** que teriamos que lidar com **bundler**, s\xf3 importamos o script onde fosse necess\xe1rio utilizar as tags do **HTMX**.\\n\\n> A simplicidade que o **HTMX** trouxe para essa implementa\xe7\xe3o, talvez tivesse sido utilizada no lugar do **react** se a conhec\xeassemos na \xe9poca.\\n\\n## Quest\xf5es t\xe9cnicas <a name=\\"tech\\"></a>\\n\\nAlgumas quest\xf5es que foram foco dos esfor\xe7os no trabalho com essa funcionalidade ser\xe3o tratadas nessa se\xe7\xe3o. Essas quest\xf5es n\xe3o foram, necessariamente, complexas ou problem\xe1ticas. S\xe3o apenas pontos aos quais gostaria de comentar.\\n\\n### Comunica\xe7\xe3o entre HTMX e React <a name=\\"react\\"></a>\\n\\nComo comentado, em algum lugar no texto acima, era necess\xe1rio clonar itens para o formul\xe1rio atual. Formul\xe1rio esse, constru\xeddo em **React**. Assim, ao integrar uma a\xe7\xe3o para clonar o item, utilizando o `hx-post`, \xe9 necess\xe1rio que algum _trigger_ seja disparado para que alguma parte da app **React** possa processar.\\n\\n> Um detalhe, ao qual n\xe3o vou adentrar aqui, \xe9 que esses \\"links\\" para a\xe7\xf5es est\xe3o dentro de um formul\xe1rio, ent\xe3o na chamada para o `hx-post` todos os campos do formul\xe1rio tamb\xe9m s\xe3o enviados.\\n\\n```html\\n<span\\n  hx-post=\\"/admin/my-action\\"\\n  hx-trigger=\\"confirmed\\"\\n  hx-indicator=\\".htmx-indicator\\"\\n  title=\\"Clonar\\"\\n>\\n  ...\\n</span>\\n```\\n\\nO `hx-trigger=\\"confirmed\\"` se deve a se\xe7\xe3o abaixo, onde tratamos sobre a confirma\xe7\xe3o para a execu\xe7\xe3o da a\xe7\xe3o. Fora isso, no lado do servidor, utilizando `django-htmx` podemos inserir uma header `HX-Trigger` para disparar um _trigger_ quando a a\xe7\xe3o do **HTMX** for finalizada:\\n\\n```python\\ndef my_view(request):\\n    ...\\n    response = render(request, \'my_template.html\', my_context)\\n    resp.headers[\'HX-Trigger\'] = \'completeClone\'\\n    return resp\\n```\\n\\nDentro do cliente **react** podemos adicionar o evento ao `document` devido ao event bubbling:\\n\\n```tsx\\nuseEffect(() => {\\n  const fetch = async () => {\\n    ...\\n  }\\n\\n  document.addEventListener(\'completeClone\', fetch);\\n  return () => {\\n    document.removeEventListener(\'completeClone\', fetch);\\n  }\\n}, []);\\n```\\n\\n### Confirma\xe7\xe3o para execu\xe7\xe3o de a\xe7\xf5es <a name=\\"confirm\\"></a>\\n\\nPara exibir confirma\xe7\xf5es de execu\xe7\xe3o das a\xe7\xf5es, utilizamos a biblioteca SweetAlert2, que j\xe1 estava no projeto pra ser utilizada em alguns outros momentos:\\n\\n```javascript\\nfunction confirmClone(element, title) {\\n  text =\\n    \'Deseja clonar o item <strong>\\"\' +\\n    title +\\n    \'\\"</strong>? Essa a\xe7\xe3o n\xe3o poder\xe1 ser desfeita!\';\\n  Swal.fire({\\n    title: \'Tem certeza?\',\\n    html: text,\\n    showCancelButton: true,\\n    confirmButtonText: \'Sim, Clonar\',\\n    cancelButtonText: \'Cancelar\',\\n  }).then(function (result) {\\n    if (!result.isConfirmed) {\\n      return;\\n    }\\n    htmx.trigger(element, \'confirmed\');\\n  });\\n}\\n```\\n\\nA linha `htmx.trigger(element, \'confirmed\');` dispara o _trigger_ que est\xe1 no `hx-trigger=\\"confirmed\\"` do `span`. Aqui \xe9 preciso completar, tamb\xe9m, a tag:\\n\\n```html\\n<span\\n  hx-post=\\"/admin/my-action\\"\\n  hx-trigger=\\"confirmed\\"\\n  hx-indicator=\\".htmx-indicator\\"\\n  onclick=\\"confirmClone(this, \'t\xedtulo do item!!!!\')\\"\\n  title=\\"Clonar\\"\\n>\\n  ...\\n</span>\\n```\\n\\n### Como \xe9 que isso ai funciona? <a name=\\"how\\"></a>\\n\\nA implementa\xe7\xe3o com **HTMX** fluiu muito bem, mas em diversos momentos foi necess\xe1ria muita experimenta\xe7\xe3o por falta de clareza do que, exatamente, os comandos fazem ou como lidar para que eles fizessem exatamente o que queria.\\n\\nMas, esse pode ser uma _skill issue_ do prazo e de ser a primeira vez utilizando a documenta\xe7\xe3o, tanto que as duas se\xe7\xf5es acima foram fortemente baseadas pelos seus exemplos (mas n\xe3o pela sua documenta\xe7\xe3o).\\n\\n## E o futuro? <a name=\\"future\\"></a>\\n\\nBom, desenvolver uma funcionalidade real com **HTMX** foi uma experi\xeancia muito boa e creio que o projeto tem muito pot\xeancial, apesar que em diversos momentos, a depender da estrutura e do tamanho do projeto, eu continue achando que uma API (Rest ou _intent based_) com um cliente front-end ainda seja mais simples de se manipular.\\n\\nAinda assim, espero ter mais chances de usar o **HTMX** integrado ao **django-admin** que \xe9, fundamentalmente, **server-side**."},{"id":"full-text-search-drf-postgres-django","metadata":{"permalink":"/blog/full-text-search-drf-postgres-django","source":"@site/blog/2023-04-22-full-text-search-django-drf-postgres/index.md","title":"Full-Text Search: Criando um Back-End de Filtro para o Django Rest-Framework","description":"This is my first post on Docusaurus.","date":"2023-04-22T00:00:00.000Z","tags":[{"inline":true,"label":"Django","permalink":"/blog/tags/django"},{"inline":true,"label":"PostgreSQL","permalink":"/blog/tags/postgre-sql"},{"inline":true,"label":"Full-Text Search","permalink":"/blog/tags/full-text-search"}],"readingTime":4.925,"hasTruncateMarker":true,"authors":[{"name":"Eduardo Oliveira","title":"Co-creator of Docusaurus 1","url":"https://github.com/EduardoJM","email":"eduardo_y05@outlook.com","page":null,"socials":{"github":"https://github.com/EduardoJM","bluesky":"https://bsky.app/profile/goticodocalypso.dev"},"imageURL":"https://github.com/EduardoJM.png","key":"EduardoJM"}],"frontMatter":{"title":"Full-Text Search: Criando um Back-End de Filtro para o Django Rest-Framework","description":"This is my first post on Docusaurus.","slug":"full-text-search-drf-postgres-django","authors":["EduardoJM"],"tags":["Django","PostgreSQL","Full-Text Search"]},"unlisted":false,"prevItem":{"title":"Django, Htmx e React: usando HTMX para al\xe9m de TODO-Lists","permalink":"/blog/django-htmx-react-alem-de-todo-lists"},"nextItem":{"title":"Full-Text Search: Implementando com Postgres e Django","permalink":"/blog/full-text-search-postgres-django"}},"content":"O texto `Full-Text Search: Implementando com Postgres e Django` [1] comenta sobre a implementa\xe7\xe3o do sistema de _Full-Text Search_ do **Postgres**, trazido pelo Leandro Proen\xe7a no texto `A powerful full-text search in PostgreSQL in less than 20 lines` [2], utilizando o **django**.\\n\\n\x3c!-- truncate --\x3e\\n\\nO projeto est\xe1 no GitHub [3] e, para complement\xe1-lo, esse texto tem por objetivo, construir um back-end de filtro, i.e. um _adapter_ de filtro, para lidar com o _full-text search_, como no algoritmo do texto anterior dentro do _rest-framework_.\\n\\nPra poder adicionar esse suporte, da melhor forma poss\xedvel, podemos criar um _filter back-end_ customizado. S\xe3o utilizados, como refer\xeancia, o `SearchFilter` original do **django** [4] e [5].\\n\\n---\\n\\n## Mostre-me o c\xf3digo\\n\\nO c\xf3digo desenvolvido nesse texto est\xe1 dispon\xedvel no reposit\xf3rio [django-full-text-search](https://github.com/EduardoJM/django-full-text-search) no Github.\\n\\n> Disclaimer:\\n>\\n> O c\xf3digo da vers\xe3o desse texto est\xe1 dispon\xedvel na branch [texto-2](https://github.com/EduardoJM/django-full-text-search/tree/texto-2).\\n\\n---\\n\\n## Implementando o BaseFilterBackend\\n\\nPara criar o back-end de filtro, \xe9 preciso implementar a classe `rest_framework.filters.BaseFilterBackend`:\\n\\n```python\\nfrom rest_framework.filters import BaseFilterBackend\\n\\nclass FullTextSearchFilter(BaseFilterBackend):\\n    pass\\n```\\n\\n### Obtendo os par\xe2metros\\n\\nOs primeiros m\xe9todos que ser\xe3o implementados na classe acima s\xe3o apenas m\xe9todos que buscam atributos na requisi\xe7\xe3o, como o par\xe2metro `?search`, ou no `ModelViewSet` como, por exemplo, o `search_fields`. Esse c\xf3digo \xe9 bem parecido com o da refer\xeancia em [5]:\\n\\n```python\\nfrom rest_framework.filters import BaseFilterBackend\\nfrom rest_framework.settings import api_settings\\n\\nclass FullTextSearchFilter(BaseFilterBackend):\\n    search_param = api_settings.SEARCH_PARAM\\n\\n    def get_config(self, view, request):\\n        return getattr(view, \\"search_config\\", None)\\n\\n    def get_search_fields(self, view, request):\\n        return getattr(view, \\"search_fields\\", None)\\n\\n    def get_similarity_threshold(self, view, request):\\n        return getattr(view, \\"similarity_threshold\\", 0)\\n\\n    def get_search_term(self, request):\\n        params = request.query_params.get(self.search_param, \'\')\\n        params = params.replace(\'\\\\x00\', \'\')  # strip null characters\\n        params = params.replace(\',\', \' \')\\n        return params\\n```\\n\\n### Fazendo a Busca\\n\\nO m\xe9todo mais importante dessa classe \xe9, sem d\xfavidas, o `filter_queryset` que \xe9 o m\xe9todo que faz as altera\xe7\xf5es em um `queryset` para devolver a resposta da API.\\n\\n\xc9 preciso, antes de tudo, obter os par\xe2metros para fazer nossa busca, por meio dos m\xe9todos implementados acima:\\n\\n```python\\ndef filter_queryset(self, request, queryset, view):\\n    search_fields = self.get_search_fields(view, request)\\n    search_term = self.get_search_term(request)\\n    config = self.get_config(view, request)\\n    threshold = self.get_similarity_threshold(view, request)\\n```\\n\\nUm primeiro ponto, que deve ser levado em considera\xe7\xe3o, \xe9 que, caso a vari\xe1vel `search_fields` ou a `search_term` n\xe3o esteja preenchida, podemos retornar o `queryset` sem fazer altera\xe7\xe3o:\\n\\n```python\\ndef filter_queryset(self, request, queryset, view):\\n    # ...\\n\\n    if not search_term or not search_fields:\\n        return queryset\\n```\\n\\nO restante do m\xe9todo \xe9 bem parecido com o que j\xe1 implementamos no texto anterior:\\n\\n```python\\ndef filter_queryset(self, request, queryset, view):\\n    # ...\\n\\n    search_vector = SearchVector(*search_fields, config=config)\\n    search_query = SearchQuery(search_term, config=config)\\n\\n    queryset = queryset.annotate(\\n        search=search_vector,\\n        rank=SearchRank(\\n            search_vector,\\n            search_query,\\n        ),\\n        similarity=TrigramSimilarity(*search_fields, search_term),\\n    ).filter(\\n        Q(search=search_query) | Q(similarity__gt=threshold)\\n    ).order_by(\\"-rank\\", \\"-similarity\\")\\n\\n    return queryset\\n```\\n\\nFaz-se importante denotar que o `search_fields` aqui \xe9 usado como `*search_fields` para \\"desconstruir\\" o array. Assim, se `search_fields = [\\"name\\", \\"description\\"]`, a cria\xe7\xe3o da inst\xe2ncia `SearchVector` seria feita como `SearchVector(\\"name\\", \\"description\\", config=config)`.\\n\\nPor fim, a classe, completa, ser\xe1:\\n\\n```python\\nclass FullTextSearchFilter(BaseFilterBackend):\\n    search_param = api_settings.SEARCH_PARAM\\n\\n    def get_config(self, view, request):\\n        return getattr(view, \\"search_config\\", None)\\n\\n    def get_search_fields(self, view, request):\\n        return getattr(view, \\"search_fields\\", None)\\n\\n    def get_similarity_threshold(self, view, request):\\n        return getattr(view, \\"similarity_threshold\\", 0)\\n\\n    def get_search_term(self, request):\\n        params = request.query_params.get(self.search_param, \'\')\\n        params = params.replace(\'\\\\x00\', \'\')  # strip null characters\\n        params = params.replace(\',\', \' \')\\n        return params\\n\\n    def filter_queryset(self, request, queryset, view):\\n        search_fields = self.get_search_fields(view, request)\\n        search_term = self.get_search_term(request)\\n        config = self.get_config(view, request)\\n        threshold = self.get_similarity_threshold(view, request)\\n\\n        if not search_term or not search_fields:\\n            return queryset\\n\\n        search_vector = SearchVector(*search_fields, config=config)\\n        search_query = SearchQuery(search_term, config=config)\\n\\n        queryset = queryset.annotate(\\n            search=search_vector,\\n            rank=SearchRank(\\n                search_vector,\\n                search_query,\\n            ),\\n            similarity=TrigramSimilarity(*search_fields, search_term),\\n        ).filter(\\n            Q(search=search_query) | Q(similarity__gt=threshold)\\n        ).order_by(\\"-rank\\", \\"-similarity\\")\\n\\n        return queryset\\n```\\n\\n---\\n\\n## Usando o FullTextSearchFilter\\n\\nA classe `FullTextSearchFilter` pode ser utilizada nos `filter_backends` dos `ModelViewSet` do _django-rest-framework_. Simplificando:\\n\\n```python\\nfrom rest_framework import serializers\\nfrom rest_framework.viewsets import ModelViewSet\\nfrom texto.models import Singer\\nfrom core.filters import FullTextSearchFilter\\n\\nclass SingerSerializer(serializers.ModelSerializer):\\n    class Meta:\\n        model = Singer\\n        fields = \\"__all__\\"\\n\\nclass SingerViewSet(ModelViewSet):\\n    queryset = Singer.objects.all()\\n    serializer_class = SingerSerializer\\n    filter_backends = [FullTextSearchFilter]\\n    search_config = \\"portuguese\\"\\n    search_fields = [\\"name\\"]\\n```\\n\\nAo registrar o `SingerViewSet` nas `urls` do projeto j\xe1 \xe9 poss\xedvel fazer chamadas para o _endpoint_ utilizando o `?search` como _full-text search_:\\n\\n```python\\nfrom django.urls import path, include\\nfrom rest_framework.routers import SimpleRouter\\nfrom .viewsets import SingerViewSet\\n\\nrouter = SimpleRouter()\\nrouter.register(\\"singer\\", SingerViewSet, \\"Singer\\")\\n\\nurlpatterns = [\\n    path(\'api/\', include(router.urls))\\n]\\n```\\n\\n![Exemplo de chamada para a API com ?search=Marrone e mostrando os resultados filtrados e ordenados de modo correto](./full_text_5.png)\\n\\n---\\n\\n## Mostrando o Rank e Similarity no retorno da API\\n\\n\xc9 poss\xedvel, inclusive, exibir os dados de `rank` e `similarity` no retorno da API. Como esses dados est\xe3o sendo anotados, i.e. acrescentados, na entidade, \xe9 poss\xedvel, apenas, alterar o `ModelSerializer`:\\n\\n```python\\nclass SingerSerializer(serializers.ModelSerializer):\\n    rank = serializers.FloatField(read_only=True)\\n    similarity = serializers.FloatField(read_only=True)\\n\\n    class Meta:\\n        model = Singer\\n        fields = \\"__all__\\"\\n```\\n\\n![Exemplo de chamada para a API com ?search=Marrone e mostrando os resultados com os campos rank e similarity sendo exibidos](./full_text_6.png)\\n\\n### Mas, e sem a busca?\\n\\nAcrescentar, apenas, o `rank` e `similarity` no `ModelSerializer` traz um problema: quando o _endpoint_ \xe9 chamado sem o `?search` os dados de `rank` e `similarity` n\xe3o s\xe3o retornados:\\n\\n![Exemplo de retorno da API sem utilizar o par\xe2metro ?search na URL e que os itens s\xe3o retornados sem o campo rank e similarity](./full_text_7.png)\\n\\nIsso pode ser resolvido, acrescentando, no construtor do FloatField, o par\xe2metro `default=0`:\\n\\n```python\\nclass SingerSerializer(serializers.ModelSerializer):\\n    rank = serializers.FloatField(read_only=True, default=0)\\n    similarity = serializers.FloatField(read_only=True, default=0)\\n\\n    class Meta:\\n        model = Singer\\n        fields = \\"__all__\\"\\n```\\n\\n---\\n\\n## Filtrando por Similaridade\\n\\nPor fim, para filtrar por similaridade, \xe9 poss\xedvel definir a vari\xe1vel `similarity_threshold` no `ModelViewSet`:\\n\\n```python\\nclass SingerViewSet(ModelViewSet):\\n    queryset = Singer.objects.all()\\n    serializer_class = SingerSerializer\\n    filter_backends = [FullTextSearchFilter]\\n    search_config = \\"portuguese\\"\\n    search_fields = [\\"name\\"]\\n    similarity_threshold = 0.3\\n```\\n\\n![Exemplo de chamada para a API com `?search=Bruninho` exibindo apenas os itens com o campo \\"similarity\\" maior que 0.3](./full_text_8.png)\\n\\n---\\n\\n## Refer\xeancias\\n\\n[1] [Full-Text Search: Implementando com Postgres e Django](https://dev.to/eduardojm/full-text-search-implementando-com-postgres-e-django-kmf)\\n\\n[2] [A powerful full-text search in PostgreSQL in less than 20 lines](https://leandronsp.com/a-powerful-full-text-search-in-postgresql-in-less-than-20-lines)\\n\\n[3] [django-full-text-search](https://github.com/EduardoJM/django-full-text-search)\\n\\n[4] [Filtering - SearchFilter](https://www.django-rest-framework.org/api-guide/filtering/#searchfilter)\\n\\n[5] [rest_framework/filters.py](https://github.com/encode/django-rest-framework/blob/master/rest_framework/filters.py#L39)\\n\\n---\\n\\n[Foto de Capa por Douglas Lopes no Unsplash](https://unsplash.com/pt-br/fotografias/ehyV_XOZ4iA)"},{"id":"full-text-search-postgres-django","metadata":{"permalink":"/blog/full-text-search-postgres-django","source":"@site/blog/2023-04-10-full-text-search-postgres-django/index.md","title":"Full-Text Search: Implementando com Postgres e Django","description":"This is my first post on Docusaurus.","date":"2023-04-10T00:00:00.000Z","tags":[{"inline":true,"label":"Django","permalink":"/blog/tags/django"},{"inline":true,"label":"PostgreSQL","permalink":"/blog/tags/postgre-sql"},{"inline":true,"label":"Full-Text Search","permalink":"/blog/tags/full-text-search"}],"readingTime":5.885,"hasTruncateMarker":true,"authors":[{"name":"Eduardo Oliveira","title":"Co-creator of Docusaurus 1","url":"https://github.com/EduardoJM","email":"eduardo_y05@outlook.com","page":null,"socials":{"github":"https://github.com/EduardoJM","bluesky":"https://bsky.app/profile/goticodocalypso.dev"},"imageURL":"https://github.com/EduardoJM.png","key":"EduardoJM"}],"frontMatter":{"title":"Full-Text Search: Implementando com Postgres e Django","description":"This is my first post on Docusaurus.","slug":"full-text-search-postgres-django","authors":["EduardoJM"],"tags":["Django","PostgreSQL","Full-Text Search"]},"unlisted":false,"prevItem":{"title":"Full-Text Search: Criando um Back-End de Filtro para o Django Rest-Framework","permalink":"/blog/full-text-search-drf-postgres-django"}},"content":"Algum tempo atr\xe1s vi o texto \\"A powerful full-text search in PostgreSQL in less than 20 lines\\" do Leandro Proen\xe7a [1] e quis implementar algo assim pra projetos que n\xe3o demandam o poder de um Apache Lucene ou de um Elastic Search.\\n\\n\x3c!-- truncate --\x3e\\n\\nO django j\xe1 possui, em seu _core_, uma aplica\xe7\xe3o com m\xe9todos que s\xe3o utilizados apenas com o **Postgres** e, para a minha surpresa, todos os conceitos de _full-text search_ j\xe1 estavam dispon\xedveis nesse _app_.\\n\\nRestou, nesse caso, tentar reproduzir, por assim dizer, a _query_ do texto original utilizando o **ORM** do django e os m\xe9todos do _full-text search_.\\n\\nEsse texto tem, por objetivo, trazer explica\xe7\xf5es sobre como essa implementa\xe7\xe3o foi feita. Fundamentalmente, esse texto ser\xe1 uma vers\xe3o explicada [dessa thread no twitter](https://twitter.com/goticodocalypso/status/1645248408066613248).\\n\\n## Mostre-me o c\xf3digo\\n\\nTodo o c\xf3digo-fonte do projeto est\xe1 dispon\xedvel no GitHub, [nesse reposit\xf3rio](https://github.com/EduardoJM/django-full-text-search).\\n\\n> Disclaimer:\\n>\\n> O c\xf3digo da vers\xe3o desse texto est\xe1 dispon\xedvel na branch [texto-1](https://github.com/EduardoJM/django-full-text-search/tree/texto-1).\\n\\n---\\n\\n## Adicionando configura\xe7\xf5es necess\xe1rias\\n\\nDentro do `settings.py` do projeto, precisamos adicionar a aplica\xe7\xe3o `django.contrib.postgres` dentro da vari\xe1vel de `INSTALLED_APPS` para que possamos utilizar as ferramentas do **django** pr\xf3prias para o **Postgres**:\\n\\n```python\\n# ...\\n\\nINSTALLED_APPS = [\\n    \'django.contrib.admin\',\\n    \'django.contrib.auth\',\\n    \'django.contrib.contenttypes\',\\n    \'django.contrib.sessions\',\\n    \'django.contrib.messages\',\\n    \'django.contrib.staticfiles\',\\n    \'django.contrib.postgres\',\\n]\\n\\n# ...\\n```\\n\\n## Criando o model\\n\\nPrecisamos criar um _model_ para poder utilizar os conceitos da busca dentro dele. Para simplificar, esse caso, utilizamos um _model_ com um \xfanico campo de texto para as buscas:\\n\\n```python\\nclass Singer(models.Model):\\n    name = models.CharField(\\"Cantor\\", max_length=150)\\n\\n    def __str__(self):\\n        return self.name\\n\\n    class Meta:\\n        verbose_name = \\"Cantor\\"\\n        verbose_name_plural = \\"Cantores\\"\\n```\\n\\n## Criando uma view\\n\\nPara testar os conceitos de _full-text search_, podemos criar uma _view_. Antes, \xe9 necess\xe1rio dizer que nesse texto estou usando _views_ padr\xe3o do **django** com _templates_ em HTML para n\xe3o adicionar mais complexidade lidando com o _Rest Framework_.\\n\\nPodemos criar uma _view_ que recebe uma _query string_ para fazer a busca:\\n\\n```python\\nfrom django.shortcuts import render\\nfrom .models import Singer\\n\\ndef search_singer(request):\\n    term = request.GET.get(\'q\')\\n    if term:\\n        # TODO: fazer busca aqui\\n    else:\\n        singers = Singer.objects.order_by(\\"-id\\").all()\\n\\n    context = {\\n        \'singers\': singers,\\n        \'term\': term,\\n    }\\n    return render(request, \\"cantor.html\\", context)\\n```\\n\\nO _template_ `cantor.html` que estou utilizando \xe9 bem simples apenas para permitir testes de forma mais f\xe1cil:\\n\\n```html\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n  <head>\\n    <meta charset=\\"UTF-8\\" />\\n    <meta http-equiv=\\"X-UA-Compatible\\" content=\\"IE=edge\\" />\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\" />\\n    <title>Buscando Cantores</title>\\n  </head>\\n  <body>\\n    <div>\\n      <form action=\\"\\">\\n        <input name=\\"q\\" {% if term %} value=\\"{{ term }}\\" {% endif %} />\\n        <button type=\\"submit\\">Pesquisar</button>\\n      </form>\\n    </div>\\n\\n    {% if singers %}\\n    <main>\\n      {% for item in singers %}\\n      <div>\\n        <h3>{{item.name}}</h3>\\n        {% if item.rank or item.similarity %}\\n        <div>Rank: {{item.rank}}, Similaridade: {{item.similarity}}</div>\\n        {% endif %}\\n      </div>\\n      {% endfor %}\\n    </main>\\n    {% endif %}\\n  </body>\\n</html>\\n```\\n\\n## Full-Text Search\\n\\nPrecisamos, primeiro, criar um **SearchVector** (_ts_vector_) e um **SearchQuery** (_tsquery_). Assim:\\n\\n```python\\nfrom django.contrib.postgres.search import SearchVector, SearchQuery\\n\\n# ...\\n\\nvector = SearchVector(\\"name\\", config=\\"portuguese\\")\\nquery = SearchQuery(term, config=\\"portuguese\\")\\n\\n# ...\\n```\\n\\nO vector \xe9 feito assim pra utilizar a coluna \\"name\\" do model **Singer**. A query \xe9 feita para processar a vari\xe1vel _term_ recebida no c\xf3digo da _view_ acima.\\n\\nO pr\xf3ximo ponto \xe9 criar _annotations_ para fazer o _select_ de campos como o _to_tsvector_ e o _ts_rank_ (o m\xe9todo `.annotate` do _Django ORM_ faz o _select_ de outros campos e agrega eles a entidade):\\n\\n```python\\nfrom django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank\\n\\n# ...\\n\\nvector = SearchVector(\\"name\\", config=\\"portuguese\\")\\nquery = SearchQuery(term, config=\\"portuguese\\")\\nsingers = Singer.objects.annotate(\\n    search=vector,\\n    rank=SearchRank(vector, query),\\n).filter(\\n    search=query\\n).order_by(\\"-rank\\").all()\\n\\n# ...\\n```\\n\\nAdicionando o c\xf3digo dentro da view, passamos a ter:\\n\\n```python\\nfrom django.shortcuts import render\\nfrom django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank\\nfrom .models import Singer\\n\\ndef search_singer(request):\\n    term = request.GET.get(\'q\')\\n    if term:\\n        vector = SearchVector(\\"name\\", config=\\"portuguese\\")\\n        query = SearchQuery(term, config=\\"portuguese\\")\\n        singers = Singer.objects.annotate(\\n            search=vector,\\n            rank=SearchRank(vector, query),\\n        ).filter(\\n            search=query\\n        ).order_by(\\"-rank\\").all()\\n    else:\\n        singers = Singer.objects.order_by(\\"-id\\").all()\\n\\n    context = {\\n        \'singers\': singers,\\n        \'term\': term,\\n    }\\n    return render(request, \\"cantor.html\\", context)\\n```\\n\\nUtilizando um pequeno grupo de dados para teste:\\n\\n![Dados sem Busca](./full_text_1.png)\\n\\nPodeos testar e verificar que passamos a ter uma busca funcional:\\n\\n![Resultado de Busca](./full_text_2.png)\\n\\nPor\xe9m, ainda temos alguns problemas, pois, por exemplo, na busca por palavras incompletas, perdemos o ranqueamento:\\n\\n![Busca incompleta](./full_text_3.png)\\n\\nNesse ponto, entra a busca por similaridade que, combinada com o _Full-Text Search_ nos permitir\xe1 fazer uma busca mais funcional.\\n\\n## Busca por Similaridade\\n\\nPrecisamos, primeiro, adicionar a extens\xe3o **pg_trgm** no banco de dados. Podemos fazer isso manualmente ou podemos criar uma _migration_ vazia e adicionar essa extens\xe3o na _migration_. Vou seguir pela segunda op\xe7\xe3o. Para a primeira, basta executar o comando no banco de dados:\\n\\n```sql\\nCREATE EXTENSION pg_trgm\\n```\\n\\nPara a segunda abordagem, podemos executar o comando `python manage.py makemigrations nome_do_app --empty` e ele criar\xe1 uma -_migration_ vazia. A partir da _migration_ vazia, podemos adicionar o import ao CreateExtension e adicionar dentro de operations:\\n\\n```python\\nfrom django.db import migrations\\nfrom django.contrib.postgres.operations import CreateExtension\\n\\n\\nclass Migration(migrations.Migration):\\n    dependencies = [\\n        (\'texto\', \'0003_alter_feat_music\'),\\n    ]\\n\\n    operations = [\\n        CreateExtension(\\"pg_trgm\\")\\n    ]\\n```\\n\\nBasta agora executar `python manage.py migrate` e teremos a extens\xe3o criada no banco de dados.\\n\\nAgora, dentro da nossa busca, podemos fazer o uso do **TrigramSimilarity** para melhorar nossos resultados. Primeiro, vamos adicionar dentro do `.annotate`:\\n\\n```python\\nfrom django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank, TrigramSimilarity\\n\\n# ...\\n\\nsingers = Singer.objects.annotate(\\n    search=vector,\\n    rank=SearchRank(vector, query),\\n    similarity=TrigramSimilarity(\\"name\\", term),\\n)\\n\\n# ...\\n```\\n\\nPrecisamos, tamb\xe9m, alterar o `.filter` para utilizar de um operador l\xf3gico **OU**. Para isso, precisamos fazer uso do `Q(condi\xe7\xe3o 1) | Q(condi\xe7\xe3o 2)` do **django**:\\n\\n```python\\nfrom django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank, TrigramSimilarity\\nfrom django.db.models import Q\\n\\n# ...\\n\\nsingers = Singer.objects.annotate(\\n    search=vector,\\n    rank=SearchRank(vector, query),\\n    similarity=TrigramSimilarity(\\"name\\", term),\\n).filter(\\n    Q(search=query) | Q(similarity__gt=0)\\n).order_by(\\"-rank\\", \\"-similarity\\").all()\\n\\n# ...\\n```\\n\\nAqui, o que fazemos \xe9 adicionar o campo de _similarity_ na nossa _query_ e filtrar pra \\"o full-text search encontrou\\" ou \\"a similaridade \xe9 maior que zero\\". A partir desse momento, fazendo a mesma busca de um dos prints acima:\\n\\n![Busca por Similaridade](./full_text_4.png)\\n\\nPor fim, nossa _view_ passa a ter o c\xf3digo:\\n\\n```python\\nfrom django.shortcuts import render\\nfrom django.db.models import Q\\nfrom django.contrib.postgres.search import (\\n    SearchQuery,\\n    SearchRank,\\n    SearchVector,\\n    TrigramSimilarity,\\n)\\nfrom .models import Singer\\n\\ndef search_singer(request):\\n    term = request.GET.get(\'q\')\\n    if term:\\n        vector = SearchVector(\\"name\\", config=\\"portuguese\\")\\n        query = SearchQuery(term, config=\\"portuguese\\")\\n        singers = Singer.objects.annotate(\\n            search=vector,\\n            rank=SearchRank(vector, query),\\n            similarity=TrigramSimilarity(\\"name\\", term),\\n        ).filter(\\n            Q(search=query) | Q(similarity__gt=0)\\n        ).order_by(\\"-rank\\", \\"-similarity\\").all()\\n    else:\\n        singers = Singer.objects.order_by(\\"-id\\").all()\\n\\n    context = {\\n        \'singers\': singers,\\n        \'term\': term,\\n    }\\n    return render(request, \\"cantor.html\\", context)\\n```\\n\\n\xc9 poss\xedvel utilizar tanto o _rank_ ou o _similarity_ para cortar valores, conforme exemplos da documenta\xe7\xe3o.\\n\\nPor \xfaltimo, podemos adicionar um \xedndice dentro do nosso _model_ para lidar com performance das queries:\\n\\n```python\\nfrom django.db import models\\nfrom django.contrib.postgres.indexes import GinIndex\\nfrom django.contrib.postgres.search import SearchVector\\n\\nclass Singer(models.Model):\\n    name = models.CharField(\\"Cantor\\", max_length=150)\\n\\n    def __str__(self):\\n        return self.name\\n\\n    class Meta:\\n        verbose_name = \\"Cantor\\"\\n        verbose_name_plural = \\"Cantores\\"\\n        indexes = [\\n            GinIndex(\\n                SearchVector(\\"name\\", config=\\"portuguese\\"),\\n                name=\\"singer_search_vector_idx\\",\\n            )\\n        ]\\n```\\n\\n---\\n\\nTodo o c\xf3digo-fonte do projeto est\xe1 dispon\xedvel no GitHub, [nesse reposit\xf3rio](https://github.com/EduardoJM/django-full-text-search).\\n\\n> Disclaimer:\\n>\\n> O c\xf3digo da vers\xe3o desse texto est\xe1 dispon\xedvel na branch [texto-1](https://github.com/EduardoJM/django-full-text-search/tree/texto-1).\\n\\n## Refer\xeancias\\n\\n1 - [A powerful full-text search in PostgreSQL in less than 20 lines\\n](https://leandronsp.com/a-powerful-full-text-search-in-postgresql-in-less-than-20-lines)\\n\\n2 - [Full text search - Django Documentation](https://docs.djangoproject.com/en/4.2/ref/contrib/postgres/search/)\\n\\n---\\n\\n[Foto de capa por Mick Haupt no Unsplash](https://unsplash.com/pt-br/fotografias/eQ2Z9ay9Wws)."}]}}')}}]);